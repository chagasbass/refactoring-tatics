REFATORAÇÃO DE CÓDIGO

-> mudar a sua estrutura sem mudar o seu comportamento

QUAIS SAO AS MOTIVACOES PARA REFATORAR UM CÓDIGO

REFACTORING

A change made to the internal structure of software to make it easier to understand and cheaper
to modify without changings its observable behavior.

É uma mudança  feita na estrutura interna de um software para que o entendimento se torne mais simples
e o custo para modificação seja menor sem que o seu comportamento original seja alterado.

Se mudamos o que o programa faz consequentemente estaremos alterando o seu comportamento
-----------------------------------------------------------------------------------------------------------
POR QUE REFATORAR?

Se um código funciona é necessário refatorar?

*Inserir mais qualidade na estrutura do código
*Um código bem escrito é mais fácil de dar manutenção , consequentemente mais barato
*Refatoração é edição Quando criamos alguma feature , pense nela inicialmente como um rascunho,
ela foi da melhor maneira naquele momento, ela funciona mas pode ser que ela seja a última versão para aquele código.

-----------------------------------------------------------------------------------------------------------
QUANDO REFATORAR?

explicação do restaurante

Imagine que vc tem uma restaurante que tem vários clientes
e que tem bastante movimento , por causa desse movimento, você deixa de limpar a cozinha
e chega um momento que tudo está impraticavel e vc tem q fechar o restaurante.

**Antes ou na criação de um teste unitário( Usar a técnica do RED,GREEN ,REFACTOR)
**Se o código atual está muito ruim
**Como parte de uma resolução de um bug
**Como parte de uma Code Review
-----------------------------------------------------------------------------------------------------------
QUANDO NÃO REFATORAR?

**Quando você não pode verificar se o código funciona
   ->Entender o código
   ->Criar os testes
   ->RED ,GREEN,REFACTOR

**Débito Técnico Massivo
  ->Código tão ruim que é melhor derrubar e criar tudo do zero

**Prazo Curto

Frase do martin Fowler Refactoring

"Other than when you are very close to a deadline...you should not put off
refatoring because you haven't got time" ( o famoso Sem tempo Irmão)

Caso isso não acontece a sua própria refatoração pode causar um novo bug
--------------------------------------------------------------------------------
PROCESSO DE REFATORAÇÃO

->Regra do escoteiro
Deixe o seu código melhor do que você encontrou

PROCESSO

->Tenha uma versão anterior estável, caso a refatoração dê algum problema
->Verificar o comportamento do código de preferência usando testes unitários para serem usados no mesmo código após a refatoração
->Aplicar a refatoração
->Verificar se o comportamento original não foi afetado.Caso seja, atualize o seu Refactor e não seus testes
--------------------------------------------------------------------------------
ESCREVENDO TESTES DE CARACTERIZAÇÃO

**SISTEMAS LEGADOS OU Q NAO EXISTAM TESTES

->Escrever testes para Falhar
->Usar a saída do teste que falhou para capturar o comportamento atual
->Escrever um teste que passe o comportamento atual
->Rodar o novo teste ele deve passar
--------------------------------------------------------------------------------
REFACTORING

->Remova as duplicações(duplicações no código são carecterísticas de débito técnico) Use O.O do jeito correto
->Melhorar a nomenclatura das variáveis, métodos e até classes para expressarem realmente o que são. (nomes devem revelar intenção)
->Diminuir as funções, métodos muito grandes.Devem ser focadas em uma responsabilidade específica.
->Reduzir o acoplamento de código.(depender sempre da abstração e não da implementação)
->Reduzir a complexidade (menos estruturas de decisão e repetição)(dividir ou eliminar as lógicas condicionais)
->Separar as responsabilidades
--------------------------------------------------------------------------------
O QUE SÃO "CODE SMELLS"  ou "BAD SMELL" E COMO PODEMOS LIDAR?

->Indica ou corresponde a um problema profundo de um sistema.
->Indica um código que necessita de refatoração
->Ajudam a verificar quais áreas do código devem ser limpas

->Não desenvolva o chamado "código olfativo" (código de uma pessoa q ja faz aquilo a bastante tempo )


PRINCÍPIO DA SURPRESA MÍNIMA

->Faça exatamente o que o usuário espera
->Seja Simple (KISS)
->Seja claro e seja consistente
-----------------------------------------------------------------------------------
CLASSIFICAÇÃO DE CODE SMELL POR MICAH MANTILA

->Bloaters 
**Código cresce de forma desnecessária frequentemente
***Com o tempo impacta na velocidade e processamento do código
****Para prevenção, crie código enxutos e focados

->Object orientation Abusers
**Relacionados a erros de uso da orientação á objetos
***Quebra de polimorfismo,Uso inapropriado de herança,criação de acoplamento inapropriado
****Uso de OO de forma correta

->Change preventers
 **Tende a acontecer em várias partes do software
 **Criação de forte acoplamento, Falta de separação de lógicas(resposabilidade unica)

->Dispensables
**Existe no código mas não tem nenhum valor ou não são usados
***Podem ser removidos com total segurana e sem nenhum esforço

->Couplers
**Acoplamento de partes do sistema que não precisam ser acopladas
***Introduz acoplamento excessivo,Acoplam partes do sistema não relacionadas
****Sistemas grandes devem ser modulares para que as alterações não afetem outras partes.

->Obfuscators
**Encobrem o comportamento ou o proposito do nosso código
***Falta de comunicação do código, não mostra o que tem q ser feito,esconde a intenção, confunde o leitor
-----------------------------------------------------------------------------
CODE SMELL NO C# POR ORGANIZAÇÃO HIERÁRQUICA

DECLARAÇÕES

var a = Process();

MÉTODOS

EFETUARFLUXO(string a, int f,double d float f);

CLASSES

nomes ruins

-----------------------------------------------------------------------------
SMELLS DE DECLARAÇÕES

PRIMITIVE OBSESSION (BLOATER)

-> Ocorre quando se é usado muitos tipos primitivos ao invés de estruturas de abstrações
-> Pode tornar o código menos legível e sem intenção e isso torna a leitura muito difícil
-> Resulta em duplicações de código pois esses valores não estão organizados em uma única estrutura

COMO RESOLVER
->Em classes, criar objetos agregadores (os Famosos Value Objects ou objetos de valor) 
para segregar esses tipos em um objeto e assim usar a O.O para trabalhar com uma abstração como um novo modelo.
->Em métodos, Introduzir variáveis nomeadas que demonstrem o que está sendo inserido ou esperado do método
->Caso sejam parâmetros, pode-se usar os parâmetros nomeados , feature do c# (pesquisar versao)
->Caso seja necessário, troque seus tipos primitivos por constantes ou Enumeradores isso aumenta a legibilidade do código.
-----------------------------------------------------------------------------
VERTICAL SEPARATION (OBSFUSCATOR)

->Variáveis e funções devem ser declaradas onde elas serão usadas.

COMO RESOLVER
->Métodos privados devem ser declarados logo abaixo de onde forem usados sem necessidade de rolagem de scroll.
->Caso você tenha um método privado que é usado por vários outros métodos , declare após o primeiro local de uso.
->A classe não deve ser tão longa a ponto de se ficar procurando as rotinas.(Quebrar a classe em classes menores).
-----------------------------------------------------------------------------

POOR NAMES (OBSFUSCATOR)
->Usar sempre nomes descritivos e evitar abreviacoes e codificações de termos quando possível.Quanto maior for o nome 
de uma variável, mais expressiva ela será.

COMO RESOLVER
->Verificar se o nome é descritivo.
->O nome deve ser apropriado de acordo com o nível de abstração.
->Tente seguir padrões
->Os nomes não devem ser ambiguos.
->Use nomes extensos para contextos extensos
->Não use abreviações
-----------------------------------------------------------------------------
DUPLICATE CODE (DISPOSABLE)
->É a raiz do mal de todo software.Seguindo o Princípio DRY (Don't repeat yourself) conseguimos 
evitar essas repetições quando possível.Umas das causas é a cópia de códigos.Tenha muito cuidado
pois mesmo parecendo que você está sendo produtivo,mas uma mudança pode desencadear muitos erros e bugs.

COMO RESOLVER
->Usar métodos de extensão (extension Methods)
->Extrair comportamento para um método
->Se for algo muito comum, pode-se colocar em um pacote para compartilhamento
->No caso de uma classe de validação como mostra o exemplo usar um pacote para validações como o Flunt,Fluent Validator etc.
-----------------------------------------------------------------------------
DEAD CODE (DISPOSABLE)
->Se livre de códigos que não são executados.Isto não adciona valor,Apenas adciona peso na sua base de código,
códigos não usados são distrações.


https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods

COMO RESOLVER
->Verifique sempre as declarações que não estão sendo usadas no seu código.
->Geralmente a própria IDE mostra essse tipo de código (selecionar o item e usar os comandos CTRL . + enter)
->Essa regra tbm serve para usings não usados
-----------------------------------------------------------------------------
HIDDEN TEMPORAL COUPLING
->Quando temos algumas operações que devem acontecer em uma determinada ordem e caso não aconteça elas não funcionam.
->Muito comum de darem problemas ao serem refatorados e sejam tirados da ordem.

COMO RESOLVER
->aplicando o pattern template method(cria-se uma classe abstrata com um método que contém os fluxos).
->Juntar os processo em diferentes classes retornando seus respectivos objetos

Robert C Martin chama isso de "Forming Bucket Brigade"
pois cada classe faz uma parte mínima do fluxo e sempre lidando com um objeto tipado como resultado
para a proxima classe e que só funciona com aquele tipo em particular.E já que são tipados e únicos
não teria como serem chamados fora de ordem.
var fluxoUm = EfetuarFluxoUm();
var fluxoDois = EfetuarFluxoDois(fluxoUm);
var fluxoTres = EfetuarFluxoTres(fluxoDois);
var fluxoQuatro = EfetuarFluxoQuatro(fluxoTres);

-----------------------------------------------------------------------------------------
METHODS CODE SMELLS

LONG METHOD (BLOATER)

->Prefira métodos curtos ao longos.Métodos curtos podem ter nomes melhores porquê fazem menos e por isso são mais fáceis de se entender.

Qual é a definição de Curtos?

-> baseando-se no clean code , um método deveria ter no máximo 30 linhas de codigo para ser considerado curto
mas ele deve ser curto para que não altere a legibilidade do seu código.
**A regra de ouro é que o seu método caiba na tela sem efetuar scroll.
**Não devem ser tão longos e nem tão curtos apenas fáceis de se entender

->COMO RESOLVER

Extração de métodos
->Faça a extração de métodos menores dentro do método maior encontrando as lógicas que podem seguir sozinhas separando as responsabilidades

**pattern Replace Conditional Dispatcher with Command

Composição de métodos
-> separar em métodos menores existindo um método "pai" para delegar a chamada dos métodos menores

**pattern Move Acumulation to Visitor

->Alterar as condicionais aninhadas por cláusulas de guarda

**Replace conditional Logic with Strategy


Visual studio safe extract method

->Selecionar o codigo e usar o atalho Ctrl . para extrair o código selecionado em um método


